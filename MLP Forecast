from math import sqrt
from numpy import array
from numpy import mean
from pandas import DataFrame
from pandas import concat
import pandas as pd
from sklearn.metrics import mean_squared_error
from keras.models import Sequential
from keras.layers import Dense


# Divide los datos en train/test
def train_test_split(data, n_test):
    return data[:-n_test], data[-n_test:]

# Transforma la serie
def series_to_supervised(data, n_in, n_out=1):
    df = DataFrame(data)
    cols = list()
# Secuencia de inputs
    for i in range(n_in, 0, -1):
        cols.append(df.shift(i))
# Secuencia de outputs
    for i in range(0, n_out):
        cols.append(df.shift(-i))
# Unir todo
    agg = concat(cols, axis=1)
# Limpia valores nulos
    agg.dropna(inplace=True)
    return agg.values

# RMSE
def measure_rmse(velorefe, prediccion):
    return sqrt(mean_squared_error(valorefe, prediccion))


# Diferencia la serie
def difference(data, order):
    return [data[i] - data[i - order] for i in range(order, len(data))]


# Entrenar modelo
def model_fit(train, config):
# Configuracion
    n_input, n_nodes, n_epochs, n_batch, n_diff = config
# Prepara el train set
    if n_diff > 0:
        train = difference(train, n_diff)
# Transforma la serie
    data = series_to_supervised(train, n_in=n_input)
# Separa inputs y outputs
    train_x, train_y = data[:, :-1], data[:, -1]
# -- MODELO --
    model = Sequential()
    model.add(Dense(n_nodes, activation='sigmoid', input_dim=n_input))
    model.add(Dense(n_nodes, activation='relu', input_dim=n_input))
    model.add(Dense(1))
    model.compile(loss='mse', optimizer='adam')
# Fitea modelo
    model.fit(train_x, train_y, epochs=n_epochs, batch_size=n_batch, verbose=0)
    return model


# Pronostico del modelo
def model_predict(model, history, config):
# Configuracion
    n_input, _, _, _, n_diff = config
# Acomoda la data
    correction = 0.0
    if n_diff > 0:
        correction = history[-n_diff]
        history = difference(history, n_diff)
# Reshape de la data
    x_input = array(history[-n_input:]).reshape((1, n_input))
# Pronostico
    yhat = model.predict(x_input, verbose=0)
# Correcion por diferenciacion
    return correction + yhat[0]

# Definir Datos
cpi = pd.read_excel(" Insertar serie ", header = 0, parse_dates = [0])
series = cpi["Nombre de la columna a utilizar"][:]
data = series.values
# Dividir datos
n_test = range(1, 18)
repeticion = range(100)
# Configuracion
config = [2, 220, 1000, 82, 1]


predicciones = list()
# Repite para cada periodo en el tiempo definido
for j in n_test:
# Forecast
    prediccion = list()
# Repite el proceso    
    for i in repeticion:
        n_input= config[1]
        datafore = data[0:len(data) - j]
        model = model_fit(datafore, config)
        forecast = model_predict(model, datafore, config)
        print(forecast)
        prediccion.append(forecast)
    resultado = mean(prediccion)
    print(resultado)
    predicciones.append(resultado)

print(predicciones)
